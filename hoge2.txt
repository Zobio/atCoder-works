0 1 2 2 1 2

0 0 0 0 1 0
0 0 0 0 1 2
0 0 1 0 1 2
0 0 1 2 1 2
0 1 1 2 1 2
0 1 2 2 1 2

2 3 3

2 2 2
2 2 3
2 3 3

0 1 2 2 2 2 
0 1 1 1 1 0
0 1 2 2 2 2

左に依存している

0 1 1 2 2 
単調非減少なら!=0の数でいい
なので注目

シミュレーションをする
0 1 2 2 1 2

0 0 0 0 1 0
0 0 0 0 1 2
0 0 1 0 1 2
0 0 1 2 1 2
0 1 1 2 1 2
0 1 2 2 1 2

単調減少しているパートに分けて処理?
(0 1 2 2 1 2) --> (0 1 2 2) (1 2)
最初の集合は、frontが0以外ダメ 
それ以降の集合は、frontが前の集合のback+1以下ならOK frontが0か1か前の集合のback+1ならコスト1, それ以外は2
2 2とかは左の要素を1に一回しなきゃいけないのでコスト2
2 4とかはムリ つまりdiffが1より大きいとダメ

(0 1 1 0 1 2 2 1 2) --> (0 1 1) (0 1 2 2) (1 2)

0 1 1 2

0 0 1 2

0 1 1 2

1 2 1

1 2

1 2 1

-1 1 -1

0 1 1 0 1 2 2 1 2
0 1 2 3 4 5 6 7 8

d = {0 0 1 3 3 3 4 6 6}
要素に-1があるならダメ
単調非減少じゃないとダメ
隣の要素と一致しているならcnt++
